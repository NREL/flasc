"""Utility functions that use FlorisModels."""

import copy
from time import perf_counter as timerpc

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from floris import TimeSeries, WindTIRose
from floris.utilities import wrap_360
from scipy import interpolate
from scipy.stats import norm

from flasc.logging_manager import LoggingManager
from flasc.utilities import utilities as fsut

logger_manager = LoggingManager()  # Instantiate LoggingManager
logger = logger_manager.logger  # Obtain the reusable logger


# Disable line too long for this file for csv block
# Some comment blocks would be confusing otherwise
# ruff: noqa: E501


def interpolate_floris_from_df_approx(
    df,
    df_approx,
    method="linear",
    wrap_0deg_to_360deg=True,
    extrapolate_ws=True,
    extrapolate_ti=True,
    mirror_nans=True,
    verbose=True,
):
    """Interpolate FLORIS predictions from a precalculated table of solutions.

    This function generates the FLORIS predictions for a set of historical
    data, 'df', quickly by linearly interpolating from a precalculated set of
    FLORIS solutions, 'df_approx'. We use linear interpolation to eliminate
    dependency of the computation time on the size of the dataframe/number of
    timeseries samples.

    Args:
        df (pd.DataFrame | FlascDataFrame): A Pandas DataFrame
        containing the timeseries for
        which the FLORIS predictions should be calculated. It should contain
        at least the columns 'wd', 'ws', and 'ti', which are respectively the
        ambient wind direction, ambient wind speed, and ambient turbulence
        intensity to be used in the FLORIS predictions. An example:

        df=
                 time                    wd     ws      ti
        0       2018-01-01 00:10:00   213.1   7.81    0.08
        1       2018-01-01 00:20:00   215.6   7.65    0.08
        ...                     ...   ...      ...     ...
        52103   2018-12-31 23:30:00    15.6   11.0    0.08
        52104   2018-12-31 23:40:00    15.3   11.1    0.08

        df_approx (pd.DataFrame): A Pandas DataFrame containing the precalculated
        solutions of the FLORIS model for a large grid of ambient wind directions,
        wind speeds and turbulence intensities. This table is typically calculated
        using the 'calc_floris_approx_table(...)' function described below, but
        can also be generated by hand using other tools like PyWake. df_approx
        typically has the form:

        df_approx=
                  wd    ws    ti    pow_000     pow_001  ...    pow_006
        0        0.0   1.0    0.03      0.0         0.0  ...        0.0
        1        3.0   1.0    0.03      0.0         0.0  ...        0.0
        ...      ...   ...   ...        ...         ...  ...        ...
        32399  357.0  24.0    0.18    5.0e6       5.0e6  ...       5.0e6
        32400  360.0  24.0    0.18    5.0e6       5.0e6  ...       5.0e6

        method (str, optional): Interpolation method, options are 'nearest' and
        'linear'. Defaults to 'linear'.
        wrap_0deg_to_360deg (bool, optional): The precalculated set of FLORIS solutions
        are typically calculates from 0 deg to 360 deg in steps of 2.0 deg or 3.0 deg.
        This means the last wind direction in the precalculated table of solutions is
        at 357.0 deg or 358.0 deg. If the user uses this for interpolation, any wind
        directions in 'df' with a value between 358.0 deg and 360.0 deg cannot be
        interpolated because it falls outside the bounds. This option copies the
        precalculated table solutions from 0 deg over to 360 deg to allow interpolation
        for the entire wind rose. Recommended to set to True. Defaults to True.
        extrapolate_ws (bool, optional): The precalculated set of FLORIS solutions,
        df_approx, only covers a finite range of wind speeds, typically from 1 m/s up
        to 25 m/s. Any wind speed values below or above this range therefore cannot
        be interpolated using the 'linear' method and therefore becomes a NaN. To
        prevent this, we can copy over the lowest and highest wind speed value interpolated
        to finite bounds to avoid this. For example, if our lowest wind speed calculated is
        1 m/s, we copy the solutions at 1 m/s over to a wind speed of 0 m/s, implicitly
        assuming these values are equal. This allows interpolation over wind speeds below
        1 m/s. Additionally, we copy the highest wind speed solutions (e.g., 25 m/s) over
        to a wind speed of 99 m/s to allow interpolation of values up to 99 m/s.
        Defaults to True.
        extrapolate_ti (bool, optional): The precalculated set of FLORIS solutions,
        df_approx, only covers a finite range of turbulence intensities, typically from
        0.03 to 0.18, being respectively 3% and 18%. In the same fashion at
        'extrapolate_ws', we copy the lowest and highest turbulence intensity solutions
        over to 0.00 and 1.00 turbulence intensity, to cover all possible conditions
        we may find and to avoid any NaN interpolation. This implicitly makes the
        assumption that the solutions at 0% TI are equal to your solutions at 3% TI,
        and that your solutions at 100% TI are equal to your solutions at 18% TI.
        This may or may not be a valid assumption for your scenario. Defaults to True.
        mirror_nans (bool, optional): The raw data for which the FLORIS predictions are
        made may contain NaNs for specific turbines, e.g., due to sensor issues or due
        to irregular turbine behavior. By setting mirror_nans=True, the NaNs for turbines
        from the raw data will be copied such that NaNs in the raw data will also mean
        NaNs in the FLORIS predictions. Recommended to set this to True to ensure the
        remainder of the energy ratio analysis is a fair and accurate comparison. Defaults
        to True.
        verbose (bool, optional): Print warnings and information to the console.
        Defaults to True.

    Returns:
        df (pd.DataFrame): The Pandas Dataframe containing the timeseries 'wd', 'ws'
        and 'ti', plus the power productions (and potentially local inflow conditions)
        of the turbines interpolated from the precalculated solutions table. For example,

        df=
                 time                    wd     ws      ti    pow_000     pow_001  ...    pow_006
        0       2018-01-01 00:10:00   213.1   7.81    0.08  1251108.2    825108.2  ...   725108.9
        1       2018-01-01 00:20:00   215.6   7.65    0.08  1202808.0    858161.8  ...   692111.2
        ...                     ...   ...      ...     ...         ...        ...  ...        ...
        52103   2018-12-31 23:30:00    15.6   11.0    0.08  4235128.7   3825108.4  ...  2725108.3
        52104   2018-12-31 23:40:00    15.3   11.1    0.08  3860281.3   3987634.7  ...  2957021.7
    """
    # Format dataframe and get number of turbines
    # df = df.reset_index(drop=('time' in df.columns))
    nturbs = fsut.get_num_turbines(df_approx)

    # Check input
    if mirror_nans:
        if "pow_000" not in df.columns or "ws_000" not in df.columns:
            raise UserWarning(
                "The option mirror_nans=True requires the raw data's wind speed and power measurements to be included in the dataframe 'df'."
            )
    else:
        logger.warning(
            "Warning: not mirroring NaNs from the raw data to the FLORIS predictions. This may skew your energy ratios."
        )

    # Check dimensionality: do we have a 2D or a 3D grid
    N_wd = len(np.unique(df_approx["wd"]))
    N_ws = len(np.unique(df_approx["ws"]))
    N_ti = len(np.unique(df_approx["ti"]))
    if (N_wd * N_ws) == df_approx.shape[0]:
        grid_type = "2d"
    elif (N_wd * N_ws * N_ti) == df_approx.shape[0]:
        grid_type = "3d"
    else:
        raise UserWarning("Incompatible df_approx table specified.")
    if verbose:
        logger.info(f"Identified the following grid type: {grid_type}.")

    # Check if all values in df fall within the precalculated solutions ranges
    if grid_type == "2d":
        cols = ["wd", "ws", "ti"]
    else:
        cols = ["wd", "ws"]

    for col in cols:
        # Check if all columns are defined
        if col not in df.columns:
            raise ValueError("Your SCADA dataframe is missing a column called '{:s}'.".format(col))
        if col not in df_approx.columns:
            raise ValueError(
                "Your precalculated solutions dataframe is missing a column called '{:s}'.".format(
                    col
                )
            )

        # Check if approximate solutions cover the entire problem space
        if (df[col].min() < (df_approx[col].min() - 1.0e-6)) | (
            df[col].max() > (df_approx[col].max() + 1.0e-6)
        ):
            logger.warning(
                "Warning: the values in df[{:s}] exceed the range in the precalculated solutions df_fi_approx[{:s}].".format(
                    col, col
                )
            )
            logger.info(
                "   minimum/maximum value in df:        ({:.3f}, {:.3f})".format(
                    df[col].min(), df[col].max()
                )
            )
            logger.info(
                "   minimum/maximum value in df:        ({:.3f}, {:.3f})".format(
                    df[col].min(), df[col].max()
                )
            )
            logger.info(
                "   minimum/maximum value in df_approx: ({:.3f}, {:.3f})".format(
                    df_approx[col].min(), df_approx[col].max()
                )
            )

    # Define which variables we must map from df_approx to df
    varnames = ["pow"]
    if "ws_000" in df_approx.columns:
        varnames.append("ws")
    if "wd_000" in df_approx.columns:
        varnames.append("wd")
    if "ti_000" in df_approx.columns:
        varnames.append("ti")

    # Map individual data entries to full DataFrame
    if verbose:
        logger.info("Mapping the precalculated solutions " + "from FLORIS to the dataframe...")
        logger.info(
            "  Creating a gridded interpolant with " + "interpolation method '%s'." % method
        )

    # Make a copy from wd=0.0 deg to wd=360.0 deg for wrapping
    if wrap_0deg_to_360deg and (not (df_approx["wd"] > 359.999999).any()):
        if not np.any(df_approx["wd"] < 0.01):
            raise UserWarning(
                "wrap_0deg_to_360deg is set to True but no solutions at wd=0 deg in the precalculated solution table."
            )
        df_subset = df_approx[df_approx["wd"] == 0.0].copy()
        df_subset["wd"] = 360.0
        df_approx = pd.concat([df_approx, df_subset], axis=0)

    # Copy TI to lower and upper bound
    if (grid_type == "3d") and extrapolate_ti:
        df_ti_lb = df_approx.loc[df_approx["ti"] == df_approx["ti"].min()].copy()
        df_ti_ub = df_approx.loc[df_approx["ti"] == df_approx["ti"].max()].copy()
        df_ti_lb["ti"] = 0.0
        df_ti_ub["ti"] = 1.0
        df_approx = pd.concat([df_approx, df_ti_lb, df_ti_ub], axis=0)

    # Copy WS to lower and upper bound
    if extrapolate_ws:
        df_ws_lb = df_approx.loc[df_approx["ws"] == df_approx["ws"].min()].copy()
        df_ws_ub = df_approx.loc[df_approx["ws"] == df_approx["ws"].max()].copy()
        df_ws_lb["ws"] = 0.0
        df_ws_ub["ws"] = 99.0
        df_approx = pd.concat([df_approx, df_ws_lb, df_ws_ub], axis=0)

    # Convert df_approx dataframe into a regular grid
    wd_array_approx = np.sort(df_approx["wd"].unique())
    ws_array_approx = np.sort(df_approx["ws"].unique())

    if grid_type == "2d":
        xg, yg = np.meshgrid(
            wd_array_approx,
            ws_array_approx,
            indexing="ij",
        )
    else:
        ti_array_approx = np.sort(df_approx["ti"].unique())
        xg, yg, zg = np.meshgrid(
            wd_array_approx,
            ws_array_approx,
            ti_array_approx,
            indexing="ij",
        )

    grid_dict = dict()
    for varname in varnames:
        colnames = ["{:s}_{:03d}".format(varname, ti) for ti in range(nturbs)]
        if grid_type == "2d":
            f = interpolate.NearestNDInterpolator(df_approx[["wd", "ws"]], df_approx[colnames])
            grid_dict["{:s}".format(varname)] = f(xg, yg)
        else:
            f = interpolate.NearestNDInterpolator(
                df_approx[["wd", "ws", "ti"]], df_approx[colnames]
            )
            grid_dict["{:s}".format(varname)] = f(xg, yg, zg)

    # Prepare an minimal output dataframe
    cols_to_copy = ["wd", "ws", "ti"]
    if "time" in df.columns:
        cols_to_copy.append("time")
    df_out = df[cols_to_copy].reset_index(drop=True).copy()

    # Use interpolant to determine values for all turbines and variables
    t0 = timerpc()
    df_out_interp_list = [df_out]
    for ii, varname in enumerate(varnames):
        if verbose:
            logger.info("     Interpolating " + varname + " for all turbines...")
        colnames = ["{:s}_{:03d}".format(varname, ti) for ti in range(nturbs)]

        if ii == 0:
            if grid_type == "2d":
                f = interpolate.RegularGridInterpolator(
                    points=(wd_array_approx, ws_array_approx),
                    values=grid_dict[varname],
                    method=method,
                    bounds_error=False,
                )
            else:
                f = interpolate.RegularGridInterpolator(
                    points=(wd_array_approx, ws_array_approx, ti_array_approx),
                    values=grid_dict[varname],
                    method=method,
                    bounds_error=False,
                )
        else:
            f.values = np.array(grid_dict[varname], dtype=float)

        # Interpolate values across grid
        if grid_type == "2d":
            out = f(df[["wd", "ws"]])
        else:
            out = f(df[["wd", "ws", "ti"]])

        if mirror_nans:
            # Copy NaNs in the raw data to the FLORIS predictions
            for cii, c in enumerate(colnames):
                if c in df.columns:
                    out[df[c].isna(), cii] = np.nan

        df_out_interp_list.append(pd.DataFrame(out, columns=colnames))

    # Add interpolated solutions to df_out
    df_out = pd.concat(df_out_interp_list, axis=1)

    if verbose:
        dt = timerpc() - t0
        logger.info(f"Finished interpolation in {dt:.3f} seconds.")

    return df_out


def calc_floris_approx_table(
    fm,
    wd_array=np.arange(0.0, 360.0, 1.0),
    ws_array=np.arange(1.0, 25.01, 1.0),
    ti_array=np.arange(0.03, 0.1801, 0.03),
    save_turbine_inflow_conditions_to_df=False,
):
    """Calculate the FLORIS approximate table from a FlorisModel object.

    This function calculates a large number of floris solutions for a rectangular grid
    of wind directions ('wd_array'), wind speeds ('ws_array'), and optionally turbulence
    intensities ('ti_array'). The variables that are saved are each turbine's power
    production, and optionally also each turbine's inflow wind direction, wind speed and
    turbulence intensity if 'save_turbine_inflow_conditions_to_df==True'.

    Args:
        fm (FlorisModel): FlorisModel object.
        wd_array (array, optional): Array of wind directions to evaluate in [deg]. This expands with the
          number of wind speeds and turbulence intensities. Defaults to np.arange(0.0, 360.0, 1.0).
        ws_array (array, optional): Array of wind speeds to evaluate in [m/s]. This expands with the
          number of wind directions and turbulence intensities. Defaults to np.arange(1.0, 25.01, 1.0).
        ti_array (array, optional): Array of turbulence intensities to evaluate in [-]. This expands with the
          number of wind directions and wind speeds. Defaults to np.arange(0.03, 0.1801, 0.03).
        save_turbine_inflow_conditions_to_df (bool, optional): When set to True, will also write each turbine's
        inflow wind direction, wind speed and turbulence intensity to the output dataframe. This increases the
        dataframe size but can provide useful information. Defaults to False.

    Returns:
        pd.DataFrame: A Pandas DataFrame containing the floris simulation results for all wind
          direction, wind speed and turbulence intensity combinations. The outputs are the power production
          for each turbine, 'pow_000' until 'pow_{nturbs-1}', and optionally als each turbine's inflow wind
          direction, wind speed and turbulence intensity when save_turbine_inflow_conditions_to_df==True.

        Example for a 7-turbine floris object with
            wd_array=np.arange(0.0, 360.0, 3.0)
            ws_array=np.arange(1.0, 25.001, 1.0)
            ti_array=np.arange(0.03, 0.1801, 0.03)
            save_turbine_inflow_conditions_to_df=True

    Yields:
        df_approx=
                  wd    ws    ti    pow_000     ws_000  wd_000  ti_000  pow_001  ...    pow_006     ws_006  wd_006  ti_006
        0        0.0   1.0    0.03      0.0      1.0       0.0     0.03     0.0  ...        0.0      1.0       0.0     0.03
        1        3.0   1.0    0.03      0.0      1.0       3.0     0.03     0.0  ...        0.0      1.0       3.0     0.03
        2        6.0   1.0    0.03      0.0      1.0       6.0     0.03     0.0  ...        0.0      1.0       6.0     0.03
        3        9.0   1.0    0.03      0.0      1.0       9.0     0.03     0.0  ...        0.0      1.0       9.0     0.03
        4       12.0   1.0    0.03      0.0      1.0      12.0     0.03     0.0  ...        0.0      1.0      12.0     0.03
        ...      ...   ...   ...        ...        ...     ...     ...           ...        ...        ...     ...     ...
        32395  345.0  25.0    0.18      0.0  24.880843   345.0     0.18     0.0  ...        0.0  24.881165   345.0     0.18
        32396  348.0  25.0    0.18      0.0  24.880781   348.0     0.18     0.0  ...        0.0  24.881165   348.0     0.18
        32397  351.0  25.0    0.18      0.0  24.880755   351.0     0.18     0.0  ...        0.0  24.881165   351.0     0.18
        32398  354.0  25.0    0.18      0.0  24.880772   354.0     0.18     0.0  ...        0.0  24.881165   354.0     0.18
        32399  357.0  25.0    0.18      0.0  24.880829   357.0     0.18     0.0  ...        0.0  24.881165   357.0     0.18
        32400  360.0  25.0    0.18      0.0  24.880829   360.0     0.18     0.0  ...        0.0  24.881165   360.0     0.18
    """
    # if ti_array is None, use the current value in the FLORIS object
    if ti_array is None:
        ti = fm.core.flow_field.turbulence_intensity
        ti_array = np.array([ti], dtype=float)

    fm = fm.copy()  # Create independent copy that we can manipulate
    num_turbines = len(fm.layout_x)

    # Format input arrays
    wd_array = np.sort(wd_array)
    ws_array = np.sort(ws_array)
    ti_array = np.sort(ti_array)
    wd_mesh, ws_mesh = np.meshgrid(wd_array, ws_array, indexing="ij")
    N_approx = len(wd_array) * len(ws_array) * len(ti_array)
    logger.info(
        "Generating a df_approx table of FLORIS solutions "
        + "covering a total of {:d} cases.".format(N_approx)
    )

    # Create solutions, one set per turbulence intensity
    fm.set(
        wind_data=WindTIRose(
            wind_directions=wd_array,
            wind_speeds=ws_array,
            turbulence_intensities=ti_array,
        )
    )
    fm.run()
    turbine_powers = fm.get_turbine_powers().reshape(-1, fm.n_turbines)  # Want flattened version

    solutions_dict = {
        "wd": fm.wind_directions,
        "ws": fm.wind_speeds,
        "ti": fm.turbulence_intensities,
    }
    for tindex in range(num_turbines):
        solutions_dict["pow_{:03d}".format(tindex)] = turbine_powers[:, tindex]
        if save_turbine_inflow_conditions_to_df:
            solutions_dict["ws_{:03d}".format(tindex)] = fm.core.flow_field.u.mean(axis=(2, 3))[
                :, tindex
            ]
            solutions_dict["wd_{:03d}".format(tindex)] = fm.wind_directions
            solutions_dict[
                "ti_{:03d}".format(tindex)
            ] = fm.core.flow_field.turbulence_intensity_field[:, tindex]
    df_approx = pd.DataFrame(solutions_dict)

    logger.info("Finished calculating the FLORIS solutions for the dataframe.")
    df_approx = df_approx.sort_values(by=["ti", "ws", "wd"])
    df_approx = df_approx.reset_index(drop=True)

    return df_approx


def add_gaussian_blending_to_floris_approx_table(df_fi_approx, wd_std=3.0, pdf_cutoff=0.995):
    """Add Gaussian blending to the precalculated FLORIS solutions.

    This function applies a Gaussian blending across the wind direction for the predicted
    turbine power productions from FLORIS. This is a post-processing step and achieves the
    same result as evaluating FLORIS directly with the UncertainFlorisModel module. However,
    having this as a postprocess step allows for rapid generation of the FLORIS solutions for
    different values of wd_std without having to re-run FLORIS.

    Args:
        df_fi_approx (pd.DataFrame): Pandas DataFrame with precalculated FLORIS solutions,
          typically generated using flasc.utilities.floris_tools.calc_floris_approx_table().
        wd_std (float, optional): Standard deviation of the Gaussian blur that is applied
          across the wind direction in degrees. Defaults to 3.0.
        pdf_cutoff (float, optional): Cut-off point of the probability density function of
          the Gaussian curve. Defaults to 0.995 and thereby includes three standard
          deviations to the left and to the right of the evaluation.

    Returns:
        pd.DataFrame: Pandas DataFrame with Gaussian-blurred precalculated
          FLORIS solutions. The DataFrame typically has the columns "wd", "ws", "ti", and
          "pow_000" until "pow_{nturbs-1}", with nturbs being the number of turbines.

    """
    # Assume the resolution to be equal to the resolution of the wind direction steps
    wd_steps = np.unique(np.diff(np.unique(df_fi_approx["wd"])))
    pmf_res = wd_steps[0]

    # Set-up Gaussian kernel
    wd_bnd = int(np.ceil(norm.ppf(pdf_cutoff, scale=wd_std) / pmf_res))
    bound = wd_bnd * pmf_res
    wd_unc = np.linspace(-1 * bound, bound, 2 * wd_bnd + 1)
    wd_unc_pmf = norm.pdf(wd_unc, scale=wd_std)
    wd_unc_pmf /= np.sum(wd_unc_pmf)  # normalize so sum = 1.0

    # Map solutions to the right shape using a NN interpolant
    F = interpolate.NearestNDInterpolator(
        x=df_fi_approx[["wd", "ws", "ti"]],
        y=df_fi_approx[[c for c in df_fi_approx.columns if "pow_" in c]],
    )

    # Create new sets to interpolate over for Gaussian kernel
    wd = df_fi_approx["wd"]
    wd = wrap_360(np.tile(wd, (len(wd_unc), 1)).T + np.tile(wd_unc, (wd.shape[0], 1)))

    ws = df_fi_approx["ws"]
    ws = np.tile(ws, (len(wd_unc), 1)).T

    ti = df_fi_approx["ti"]
    ti = np.tile(ti, (len(wd_unc), 1)).T

    # Interpolate power values
    turbine_powers = F(wd, ws, ti)
    weights = np.tile(
        wd_unc_pmf[None, :, None], (turbine_powers.shape[0], 1, turbine_powers.shape[2])
    )
    turbine_powers_gaussian = np.sum(weights * turbine_powers, axis=1)  # Weighted sum

    pow_cols = [c for c in df_fi_approx.columns if c.startswith("pow_")]
    df_fi_approx_gauss = pd.concat(
        [
            df_fi_approx[["wd", "ws", "ti"]],
            pd.DataFrame(dict(zip(pow_cols, turbine_powers_gaussian.T))),
        ],
        axis=1,
    )

    return df_fi_approx_gauss


# TODO Is this function in the right module?
# TODO Should include itself have a default?
def get_turbs_in_radius(
    x_turbs, y_turbs, turb_no, max_radius, include_itself, sort_by_distance=False
):
    """Find turbines within a certain radius of a turbine.

    Determine which turbines are within a certain radius of other
    wind turbines.

    Args:
        x_turbs ([list, array]): Long. locations of turbines
        y_turbs ([list, array]): Lat. locations of turbines
        turb_no (int): Turbine number for which the distance is
        calculated w.r.t. the other turbines.
        max_radius (float): Maximum distance between turbines to be
        considered within the radius of turbine [turb_no].
        include_itself (bool): Include itself in the list of turbines
        within the radius.
        sort_by_distance (bool, optional): Sort the output list of turbines
        according to distance to the turbine, from closest to furthest (but
        still within radius). Defaults to False.

    Returns:
        list: List of turbines that are within the
        prespecified distance from turbine [turb_no].
    """
    dr_turb = np.sqrt((x_turbs - x_turbs[turb_no]) ** 2.0 + (y_turbs - y_turbs[turb_no]) ** 2.0)
    turbine_list = np.array(range(len(x_turbs)))

    if sort_by_distance:
        indices_sorted = np.argsort(dr_turb)
        dr_turb = dr_turb[indices_sorted]
        turbine_list = turbine_list[indices_sorted]

    turbs_within_radius = turbine_list[dr_turb <= max_radius]
    if not include_itself:
        turbs_within_radius = [ti for ti in turbs_within_radius if not ti == turb_no]

    return turbs_within_radius


def get_all_impacting_turbines_geometrical(
    fm, turbine_weights, wd_array=np.arange(0.0, 360.0, 3.0), wake_slope=0.30
):
    """Get all impacting turbines using a simple geometric model.

    Determine which turbines affect the turbines of interest
    (i.e., those with a turbine_weights > 0.00001). This function
    uses very simplified geometric functions to very quickly
    derive which turbines are supposedly waking at least one
    turbine in the farm of interest.

    Args:
        fm (FlorisModel): FLORIS object of the farm of interest.
        turbine_weights (list): List of with turbine weights with length
            equal to the number of wind turbines, and typically filled with
            0s (neighboring farms) and 1s (farm of interest).
        wd_array (array, optional): Array of wind directions to evaluate in [deg].
        wake_slope (float, optional): linear slope of the wake (dy/dx)

    Returns:
        pd.Dataframe: A Pandas Dataframe in which each row
        contains a wind direction and a list of turbine numbers. The turbine
        numbers are those turbines that should be modelled to accurately
        capture the wake losses for the wind farm of interest. Turbine numbers
        that are not in the 'impacting_turbines' can safely be removed from
        the simulation without affecting any of the turbines that have a nonzero
        turbine weight.
    """
    # Get farm layout
    x = fm.layout_x
    y = fm.layout_y
    n_turbs = len(x)
    D = [t["rotor_diameter"] for t in fm.core.farm.turbine_definitions]
    D = np.array(D, dtype=float)

    # Rotate farm and determine freestream/waked turbines
    is_impacting_list = []
    for wd in wd_array:
        is_impacting = [None for _ in range(n_turbs)]

        # Rotate according to freestream wind direction
        x_rot = np.cos((wd - 270.0) * np.pi / 180.0) * x - np.sin((wd - 270.0) * np.pi / 180.0) * y
        y_rot = np.sin((wd - 270.0) * np.pi / 180.0) * x + np.cos((wd - 270.0) * np.pi / 180.0) * y

        # Get turbine indices of the farm turbines of interest, and find its most downstream location
        turb_ids_of_interest = np.where(turbine_weights > 0.0001)[0]
        x_rot_most_downstream_of_interest = np.max(x_rot[turb_ids_of_interest])

        # Check for each turbine
        for ii in range(n_turbs):
            # Check easy skips: turbine is in farm of interest
            if ii in turb_ids_of_interest:
                is_impacting[ii] = True
                continue

            # Check easy skips: further downstream than last turbine
            if x_rot[ii] >= x_rot_most_downstream_of_interest:
                is_impacting[ii] = False
                continue

            x0 = x_rot[ii]
            y0 = y_rot[ii]

            def yw_upper(x):
                y = (y0 + D[ii]) + (x - x0) * wake_slope
                if isinstance(y, (float, np.float64, np.float32)):
                    if x < (x0 + 0.01):
                        y = -np.Inf
                else:
                    y[x < x0 + 0.01] = -np.Inf
                return y

            def yw_lower(x):
                y = (y0 - D[ii]) - (x - x0) * wake_slope
                if isinstance(y, (float, np.float64, np.float32)):
                    if x < (x0 + 0.01):
                        y = -np.Inf
                else:
                    y[x < x0 + 0.01] = -np.Inf
                return y

            def is_in_wake(xt, yt):
                return (yt < yw_upper(xt)) & (yt > yw_lower(xt))

            is_impacting[ii] = any(
                is_in_wake(x_rot[turb_ids_of_interest], y_rot[turb_ids_of_interest])
            )

        is_impacting_list.append(np.where(is_impacting)[0])

    n_turbines_reduced = [len(ids) for ids in is_impacting_list]
    df_impacting_simple = pd.DataFrame(
        {
            "wd": wd_array,
            "impacting_turbines": is_impacting_list,
            "n_turbines_reduced": n_turbines_reduced,
        }
    )
    return df_impacting_simple


def get_upstream_turbs_floris(fm, wd_step=0.1, wake_slope=0.10, plot_lines=False):
    """Use FLORIS to determine which turbines are operating in freestream flow.

    Determine which turbines are operating in freestream (unwaked)
    flow, for the entire wind rose. This function will return a data-
    frame where each row will present a wind direction range and a set
    of wind turbine numbers for which those turbines are operating
    upstream. This is useful in determining the freestream conditions.

    Args:
        fm ([FlorisModel): FLORIS object of the farm of interest.
        wd_step (float, optional): Wind direction discretization step.
        It will test what the upstream turbines are every [wd_step]
        degrees. A lower number means more accurate results, but
        typically there's no real benefit below 2.0 deg or so.
        Defaults to 0.1.
        wake_slope (float, optional): linear slope of the wake (dy/dx)
        plot_lines (bool, optional): Enable plotting wakes/turbines.
        Defaults to False.

    Returns:
        df_upstream (pd.Dataframe): A Pandas Dataframe in which each row
        contains a wind direction range and a list of turbine numbers. For
        that particular wind direction range, the turbines numbered are
        all upstream according to the FLORIS predictions. Depending on
        the FLORIS model parameters and ambient conditions, these results
        may vary slightly. Though, having minimal wake losses should not
        noticably affect your outcomes. Empirically, this approach has
        yielded good results with real SCADA data for determining what
        turbines are waked/unwaked and has served useful for determining
        what turbines to use as reference.
    """
    # Get farm layout
    x = fm.layout_x
    y = fm.layout_y
    n_turbs = len(x)
    D = [t["rotor_diameter"] for t in fm.core.farm.turbine_definitions]
    D = np.array(D, dtype=float)

    # Setup output list
    upstream_turbs_ids = []  # turbine numbers that are freestream
    upstream_turbs_wds = []  # lower bound of bin

    # Rotate farm and determine freestream/waked turbines
    for wd in np.arange(0.0, 360.0, wd_step):
        is_freestream = [True for _ in range(n_turbs)]
        x_rot = np.cos((wd - 270.0) * np.pi / 180.0) * x - np.sin((wd - 270.0) * np.pi / 180.0) * y
        y_rot = np.sin((wd - 270.0) * np.pi / 180.0) * x + np.cos((wd - 270.0) * np.pi / 180.0) * y

        if plot_lines:
            fig, ax = plt.subplots()
            for ii in range(n_turbs):
                ax.plot(x_rot[ii] * np.ones(2), [y_rot[ii] - D[ii] / 2, y_rot[ii] + D[ii] / 2], "k")
            for ii in range(n_turbs):
                ax.text(x_rot[ii], y_rot[ii], "T%03d" % ii)
            ax.axis("equal")

        srt = np.argsort(x_rot)
        x_rot_srt = x_rot[srt]
        y_rot_srt = y_rot[srt]
        for ii in range(n_turbs):
            x0 = x_rot_srt[ii]
            y0 = y_rot_srt[ii]

            def yw_upper(x):
                y = (y0 + D[ii]) + (x - x0) * wake_slope
                if isinstance(y, (float, np.float64, np.float32)):
                    if x < (x0 + 0.01):
                        y = -np.Inf
                else:
                    y[x < x0 + 0.01] = -np.Inf
                return y

            def yw_lower(x):
                y = (y0 - D[ii]) - (x - x0) * wake_slope
                if isinstance(y, (float, np.float64, np.float32)):
                    if x < (x0 + 0.01):
                        y = -np.Inf
                else:
                    y[x < x0 + 0.01] = -np.Inf
                return y

            def is_in_wake(xt, yt):
                return (yt < yw_upper(xt)) & (yt > yw_lower(xt))

            is_freestream = (
                is_freestream
                & ~is_in_wake(x_rot_srt, y_rot_srt + D / 2.0)
                & ~is_in_wake(x_rot_srt, y_rot_srt - D / 2.0)
            )

            if plot_lines:
                x1 = np.max(x_rot_srt) + 500.0
                ax.fill_between(
                    [x0, x1, x1, x0],
                    [yw_upper(x0 + 0.02), yw_upper(x1), yw_lower(x1), yw_lower(x0 + 0.02)],
                    alpha=0.1,
                    color="k",
                    edgecolor=None,
                )

        usrt = np.argsort(srt)
        is_freestream = is_freestream[usrt]
        turbs_freestream = list(np.where(is_freestream)[0])

        if len(upstream_turbs_wds) == 0:
            upstream_turbs_ids.append(turbs_freestream)
            upstream_turbs_wds.append(wd)
        elif not (turbs_freestream == upstream_turbs_ids[-1]):
            upstream_turbs_ids.append(turbs_freestream)
            upstream_turbs_wds.append(wd)

        if plot_lines:
            ax.set_title("wd = %03d" % wd)
            ax.set_xlim([np.min(x_rot) - 500.0, x1])
            ax.set_ylim([np.min(y_rot) - 500.0, np.max(y_rot) + 500.0])
            ax.plot(x_rot[turbs_freestream], y_rot[turbs_freestream], "o", color="green")

    # # Connect at 360 degrees
    # if upstream_turbs_ids[0] == upstream_turbs_ids[-1]:
    #     upstream_turbs_wds.pop(0)
    #     upstream_turbs_ids.pop(0)

    # Go from list to bins for upstream_turbs_wds
    upstream_turbs_wds = [
        [upstream_turbs_wds[i], upstream_turbs_wds[i + 1]]
        for i in range(len(upstream_turbs_wds) - 1)
    ]
    upstream_turbs_wds.append([upstream_turbs_wds[-1][-1], 360.0])

    df_upstream = pd.DataFrame(
        {
            "wd_min": [wd[0] for wd in upstream_turbs_wds],
            "wd_max": [wd[1] for wd in upstream_turbs_wds],
            "turbines": upstream_turbs_ids,
        }
    )

    return df_upstream


def get_dependent_turbines_by_wd(
    fm_in,
    test_turbine,
    wd_array=np.arange(0.0, 360.0, 2.0),
    change_threshold=0.001,
    limit_number=None,
    ws_test=9.0,
    return_influence_magnitudes=False,
):
    """Get dependent turbines for a test turbine for each wind direction.

    Computes all turbines that depend on the operation of a specified
    turbine (test_turbine) for each wind direction in wd_array, using
    the FLORIS model specified by fm_in to detect dependencies.

    Args:
        fm_in (FlorisModels): FLORIS object of the farm of interest.
        test_turbine (int): Turbine for which dependencies are found.
        wd_array ([np.array]): Wind directions at which to determine
            dependencies. Defaults to [0, 2, ... , 358].
        change_threshold (float): Fractional change in power needed
            to denote a dependency. Defaults to 0. (any change in power
            is marked as a dependency)
        limit_number (int | NoneType): Number of turbines that a
            turbine can have as dependencies. If None, returns all
            turbines that depend on each turbine. Defaults to None.
        ws_test (float): Wind speed at which FLORIS model is run to
            determine dependencies.  Defaults to 9. m/s.
        return_influence_magnitudes (Bool): Flag for whether to return
            an array containing the magnitude of the influence of the
            test_turbine on all turbines.

    Returns:
        A tuple containing:
            dep_indices_by_wd (list): A 2-dimensional list. Each element of
                the outer level list, which represents wind direction,
                contains a list of the turbines that depend on test_turbine
                for that wind direction. The second-level list may be empty
                if no turbine depends on the test_turbine for that wind
                direciton (e.g., the turbine is in the back row).
            all_influence_magnitudes ([np.array]): 2-D numpy array of
                influences of test_turbine on all other turbines, with size
                (number of wind directions) x (number of turbines). Returned
                only if return_influence_magnitudes is True.
    """
    # Copy fi to a local to not mess with incoming
    fm = copy.deepcopy(fm_in)

    # Compute the base power
    fm.set(
        wind_data=TimeSeries(
            wind_directions=wd_array, wind_speeds=ws_test, turbulence_intensities=0.06
        )
    )
    fm.run()
    base_power = fm.get_turbine_powers()

    # Compute the test power
    if len(fm.core.farm.turbine_type) > 1:
        # Remove test turbine from list
        fm.core.farm.turbine_type.pop(test_turbine)
    else:  # Only a single turbine type defined for the whole farm; do nothing
        pass
    fm.set(
        layout_x=np.delete(fm.layout_x, [test_turbine]),
        layout_y=np.delete(fm.layout_y, [test_turbine]),
        wind_speeds=ws_test * np.ones_like(wd_array),
        wind_directions=wd_array,
    )  # This will reindex the turbines; undone in following steps.
    fm.run()
    test_power = fm.get_turbine_powers()
    test_power = np.insert(test_power, test_turbine, base_power[:, test_turbine], axis=1)

    if return_influence_magnitudes:
        all_influence_magnitudes = np.zeros_like(test_power)

    # Find the indices that have changed
    dep_indices_by_wd = [None] * len(wd_array)
    for i in range(len(wd_array)):
        all_influences = np.abs(test_power[i, :] - base_power[i, :]) / base_power[i, :]
        # Sort with highest influence first; trim to limit_number
        influence_order = np.flip(np.argsort(all_influences))[:limit_number]
        # Mask to only those that meet the threshold
        influence_order = influence_order[all_influences[influence_order] >= change_threshold]

        # Store in output
        dep_indices_by_wd[i] = list(influence_order)
        if return_influence_magnitudes:
            all_influence_magnitudes[i, :] = all_influences

    # Remove the turbines own indice
    if return_influence_magnitudes:
        return dep_indices_by_wd, all_influence_magnitudes
    else:
        return dep_indices_by_wd


def get_all_dependent_turbines(
    fm_in,
    wd_array=np.arange(0.0, 360.0, 2.0),
    change_threshold=0.001,
    limit_number=None,
    ws_test=9.0,
):
    """Get all dependent turbines for each turbine in the farm.

    Wrapper for get_dependent_turbines_by_wd() that loops over all
    turbines in the farm and packages their dependencies as a pandas
    dataframe.

    Args:
        fm_in (FlorisModel): FLORIS object of the farm of interest.
        wd_array ([np.array]): Wind directions at which to determine
            dependencies. Defaults to [0, 2, ... , 358].
        change_threshold (float): Fractional change in power needed
            to denote a dependency. Defaults to 0. (any change in power
            is marked as a dependency)
        limit_number (int | NoneType): Number of turbines that a
            turbine can have as dependencies. If None, returns all
            turbines that depend on each turbine. Defaults to None.
        ws_test (float): Wind speed at which FLORIS model is run to
            determine dependencies. Defaults to 9. m/s.

    Returns:
        df_out (pd.Dataframe): A Pandas Dataframe in which each row
            contains a wind direction, each column is a turbine, and
            each entry is the turbines that depend on the column turbine
            at the row wind direction. Dependencies can be extracted
            as: For wind direction wd, the turbines that depend on
            turbine T are df_out.loc[wd, T]. Dependencies are ordered,
            with strongest dependencies appearing first.
    """
    results = []
    for t_i in range(len(fm_in.layout_x)):
        results.append(
            get_dependent_turbines_by_wd(
                fm_in, t_i, wd_array, change_threshold, limit_number, ws_test
            )
        )

    df_out = (
        pd.DataFrame(data=results, columns=wd_array)
        .transpose()
        .reset_index()
        .rename(columns={"index": "wd"})
        .set_index("wd")
    )

    return df_out


def get_all_impacting_turbines(
    fm_in,
    wd_array=np.arange(0.0, 360.0, 2.0),
    change_threshold=0.001,
    limit_number=None,
    ws_test=9.0,
):
    """Get all impacting turbines for each turbine in the farm.

    Calculate which turbines impact a specified turbine based on the
    FLORIS model. Essentially a wrapper for
    get_dependent_turbines_by_wd() that loops over all turbines and
    extracts their impact magnitudes, then sorts.

    Args:
        fm_in (FlorisModel): FLORIS object of the farm of interest.
        wd_array ([np.array]): Wind directions at which to determine
            dependencies. Defaults to [0, 2, ... , 358].
        change_threshold (float): Fractional change in power needed
            to denote a dependency. Defaults to 0. (any change in power
            is marked as a dependency)
        limit_number (int | NoneType): Number of turbines that a
            turbine can depend on. If None, returns all
            turbines that each turbine depends on. Defaults to None.
        ws_test (float): Wind speed at which FLORIS model is run to
            determine dependencies. Defaults to 9. m/s.

    Returns:
        df_out (pd.Dataframe): A Pandas Dataframe in which each row
            contains a wind direction, each column is a turbine, and
            each entry is the turbines that the column turbine depends
            on at the row wind direction. Dependencies can be extracted
            as: For wind direction wd, the turbines that impact turbine
            T are df_out.loc[wd, T]. Impacting turbines are simply
            ordered by magnitude of impact.
    """
    dependency_magnitudes = np.zeros((len(wd_array), len(fm_in.layout_x), len(fm_in.layout_x)))

    for t_i in range(len(fm_in.layout_x)):
        _, ti_dep_mags = get_dependent_turbines_by_wd(
            fm_in,
            t_i,
            wd_array,
            change_threshold,
            limit_number,
            ws_test,
            return_influence_magnitudes=True,
        )
        dependency_magnitudes[:, :, t_i] = ti_dep_mags

    # Sort
    impact_order = np.flip(np.argsort(dependency_magnitudes, axis=2), axis=2)

    # Truncate to limit_number
    impact_order = impact_order[:, :, :limit_number]

    # Build up multi-level results list
    results = []

    for wd in range(len(wd_array)):
        wd_results = []
        for t_j in range(len(fm_in.layout_x)):
            impacts_on_t_j = dependency_magnitudes[wd, t_j, :]
            impact_order_t_j = impact_order[wd, t_j, :]
            impact_order_t_j = impact_order_t_j[
                impacts_on_t_j[impact_order_t_j] >= change_threshold
            ]
            wd_results.append(list(impact_order_t_j))
        results.append(wd_results)

    # Convert to dataframe
    df_out = (
        pd.DataFrame(data=results, index=wd_array)
        .reset_index()
        .rename(columns={"index": "wd"})
        .set_index("wd")
    )

    return df_out


# Wrapper function to easily set new TI values
def _fi_set_ws_wd_ti(fm, wd=None, ws=None, ti=None):
    nturbs = len(fm.layout_x)

    # Convert scalar values to lists
    if not isinstance(wd, list):
        if isinstance(wd, np.ndarray):
            wd = list(wd)
        elif wd is not None:
            wd = list(np.repeat(wd, nturbs))
    if not isinstance(ws, list):
        if isinstance(ws, np.ndarray):
            ws = list(ws)
        elif ws is not None:
            ws = list(np.repeat(ws, nturbs))
    if not isinstance(ti, list):
        if isinstance(ti, np.ndarray):
            ti = list(ti)
        elif ti is not None:
            ti = list(np.repeat(ti, nturbs))

    wind_layout = (np.array(fm.layout_x), np.array(fm.layout_y))

    fm.reinitialize_flow_field(
        wind_layout=wind_layout, wind_direction=wd, wind_speed=ws, turbulence_intensity=ti
    )
    return fm
